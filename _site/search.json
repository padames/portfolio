[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Engineering bits",
    "section": "",
    "text": "This is the home for a few short posts and presentations made throughout the years. Most are related to subjects of personal interest like data modeling and visualization. I am also very fond of Machine Learning, High-Performance computing, and computer languages in general.\n\nEverything here is licensed under Creative Commons Attribution-ShareAlike 4.0 International\n\nIn general most endeavors thrive when we collaborate and share our failures as much as our successes. This is specially true given the observation that there are far more paths leading to failure that to success. It pays to know how to fail as much as how to succeed.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nAnimation to explain coupled time-series\n\n\n\n\n\n\n\nVisualization\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nDec 15, 2024\n\n\nPablo Adames\n\n\n\n\n\n\n  \n\n\n\n\nHow to create a GIF file from individual images\n\n\n\n\n\n\n\nVisualization\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nSep 6, 2021\n\n\nPablo Adames\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Animation to explain coupled time-series",
    "section": "",
    "text": "I consider Edward R. Tufte one of the modern experts in data visualization. I was able to attend one of his talks in Seattle in May, 2019. We walked away with a beautiful set of his most important books and the challenge of stuffing them in my carry-on bag on the flight back to Calgary.\nAside from the pleasant experience and the wonderful books I bring this up because there are two kinds of data visualization examples he introduces at the beginning of his book, “The Visual Display of Quantitative Information”: data maps and time series. Visual excellence, Tufte claims in his book, is achieved when one can convey an idea in the shortest time using the least amount of ink and printed space to an observer.\nOne of the time-series examples is a facet grid plot representing the evolution of unemployment rate and inflation in several countries. The term facet grid, of course is adopted from ggplot lingo."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is a personal blog with entries reflecting my professional interests in computer languages and data analysis and visualization.\nMost of my professional experience has been developing Engineering applications using Matlab for modelling and C++ for library implementation. I used to like Python but strongly typed or more declarative languages win the day for me. I have way too many books on Haskell, a language that has formed me in many ways. I love functional programming and I am so glad C++ and Python have embraced it.\nIn the last 5 years, after completing a Master of Engineering in Software Engineering at the University of Calgary I have had the chance to designing and use relational and document (also called noSQL) databases for system development.\nI am pretty good at Linux bash programming as some of my colleagues at work know too well. However I am fonder of more Lispy languages like R when it comes to scripting. As far as natively compiled languages I recently I took up Rust after realizing how much of an improvement it is over C and C++ in terms of memory safety and overall speed of development.\nI will write more on this Rust journey because I think this is technology that can change the way we build software infrastructure."
  },
  {
    "objectID": "posts/welcome/index.html#the-problem-statement",
    "href": "posts/welcome/index.html#the-problem-statement",
    "title": "Animation to explain coupled time-series",
    "section": "The problem statement",
    "text": "The problem statement\nOne of the examples used in Hadley Wickham’s book, “ggplot2 - Elegant Grahics for Data Analysis”, has also to do with the representation of time evolution of two economic variables related to unemployment in the USA. The current computational resources available to us have made it relatively easy to address these visualization challenges to achieve visual excellence.\nThis blog post is about the way we can add a third dimension to a 2-D plot using animation to explore the evolution of two related time-series.\nIndividual time dependent variables are easily visualized by drawing their time series representation on a two-dimensional plot. The difficulty becomes visualizing two time series in the same traditional graph. One elegant solution was mentioned in Tufte’s book mentioned in the introduction to this post. Let’s use animation to add more insight into the data."
  },
  {
    "objectID": "posts/welcome/index.html#the-economics-data-set",
    "href": "posts/welcome/index.html#the-economics-data-set",
    "title": "Animation to explain coupled time-series",
    "section": "The economics data set",
    "text": "The economics data set\nThese examples are re-used from section 2.6.5 of https://ggplot2-book.org/getting-started#sec-line.\nThe data set called economics from the ggplot2 package, has employment statistics on the US measured over the last 40 years up until 2015.\nHere is a brief look at the first 5 out of 574 rows of the dataframe economics.\n\ndata &lt;- head(economics, n=5)\nknitr::kable(data)\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n1967-07-01\n506.7\n198712\n12.6\n4.5\n2944\n\n\n1967-08-01\n509.8\n198911\n12.6\n4.7\n2945\n\n\n1967-09-01\n515.6\n199113\n11.9\n4.6\n2958\n\n\n1967-10-01\n512.2\n199311\n12.9\n4.9\n3143\n\n\n1967-11-01\n517.4\n199498\n12.8\n4.7\n3066"
  },
  {
    "objectID": "posts/welcome/index.html#visualizing-the-unemployment-rate",
    "href": "posts/welcome/index.html#visualizing-the-unemployment-rate",
    "title": "Animation to explain coupled time-series",
    "section": "Visualizing the Unemployment Rate",
    "text": "Visualizing the Unemployment Rate\nLet’s first make a simple time series plot of the unemployment rate. This is a continuous variable that is computed with the ratio unemploy/pop.\nIn ggplot2 a frame defines the first mapping from variables to a space where the data will be represented. It is created with the function aes(). The obvious frame for this plot is defined by the two variables date and unemploy / pop. They are mapped to the x and y coordinates of a 2-D plane. The glyphs drawn over this frame will be lines between the data points located in the frame, they are created with the function geom_line(). This function defines a layer over the frame.\n\nggplot(data = economics, mapping = aes(x = date, y = unemploy / pop)) +\n  geom_line()\n\n\n\n\nTechnically speaking unemploy / pop represents the “population rate of unemployment as a fraction of the population able to work that is unemployed”, (https://www.bls.gov/cps/cps_htgm.htm#definitions)"
  },
  {
    "objectID": "posts/welcome/index.html#visualizing-the-unemployment-median-duration-in-weeks",
    "href": "posts/welcome/index.html#visualizing-the-unemployment-median-duration-in-weeks",
    "title": "Animation to explain coupled time-series",
    "section": "Visualizing the unemployment median duration in weeks",
    "text": "Visualizing the unemployment median duration in weeks\nAnother variable called uempmed from the same dataset tracks the median length of time in weeks of unemployment.\n\nggplot(economics, aes(date, uempmed)) +\n  geom_line()\n\n\n\n\nFrom these two plots one can observe the recent trend towards longer median unemployment time in the decade of 2010. There are also cycles of between 5 and 10 years of peak unemployment rates.\nAn interesting question is how these two time series correlate over time. Are there interactions between these two variables that we could observe in one plot?"
  },
  {
    "objectID": "posts/welcome/index.html#visualizing-both-variables-in-the-same-plot",
    "href": "posts/welcome/index.html#visualizing-both-variables-in-the-same-plot",
    "title": "Animation to explain coupled time-series",
    "section": "Visualizing both variables in the same plot",
    "text": "Visualizing both variables in the same plot\nIn ggplot2, the frame for a representation that shows both variables on an line plot can be defined by a mapping of each variable to the x and y coordinates of the plane. We can create two types of glyphs over it: one is points shown by a layer defined by geom_point to show the location of the variables at a point in time. The other type of glyph is lines to show the sequential trajectory, ordered by time, from one point to the next. This is captured by the layer geom_path. The figure below shows such a graph.\n\nggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path() +\n  geom_point()\n\n\n\n\nIt is hard to understand the direction of time from the lines alone. For example, it is difficult to visualize where the first, the last, or any years in between have happened.\nThis can be addressed by adding a mapping from the property colour to the variable year in the layer geom_point. R uses a default colour scale to assign specific colours from a colour palette to years.\nThe ggplot2 package defines the function aes() to create this many to many mapping.\n\nyear &lt;- function(x) as.POSIXlt(x)$year + 1900\nggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path(colour = \"grey50\") +\n  geom_point(aes(colour = year(date)))\n\n\n\n\nThe layer geom_path has a mapping from each line created between points to the same colour value indicated by the specification “grey50”. The syntax does not require the use of the aes() function. It is a many to one mapping.\nThis plot is a good attempt at representing the time dimension with a varying shade of colour. This solution is not entirely satisfactory because the lines get too entangled making the progress of time confusing in some quadrants."
  },
  {
    "objectID": "posts/welcome/index.html#animation-to-the-rescue",
    "href": "posts/welcome/index.html#animation-to-the-rescue",
    "title": "Animation to explain coupled time-series",
    "section": "Animation to the rescue",
    "text": "Animation to the rescue\nWe can get a more sophisticated visualization by using animation to explain how the two variables change simultaneously as time passes. In the following plot, the values of unemployment rate and median unemployment length in weeks are displayed for every year. By pressing the PLAY button, one sees the points for each year over the line trajectory, from beginning to end. One can use the slider to visualize the position of the variables for any given year.\n\nlibrary(plotly)\nyear &lt;- function(x) as.POSIXlt(x)$year + 1900\np &lt;- ggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path(colour = \"grey75\") +\n  geom_point(aes(colour = year(date), frame = year(date)))\n\nfig &lt;- ggplotly(p)\n\nfig &lt;- fig %&gt;% animation_opts(1000,\n                              easing = \"elastic\", \n                              redraw = FALSE )\nfig &lt;- fig %&gt;% animation_button(x = 0.05, xanchor = \"left\",\n                                y = 1.1, yanchor = \"top\")\nfig &lt;- fig %&gt;% animation_slider(currentvalue = list(prefix = \"YEAR \",\n                                                    font = list(color=\"red\")))\nfig\n\n\n\n\n\nFrom watching the motion of the annual data after pressing the Play button, one gets the sense that for the first 41 years the values of these two time series remained within the quadrant below the 15 week and to the left of 4% unemployment rate except for the years 1982 and 83. Then after 2009 the median unemployment length in weeks has increased over and above any value of the previous years in the USA according to this dataset.\nThe animation has achieved the introduction of a new dimension to represent the flow of time over the bi-dimensional plane representing the two time observed variables. In non-digital media the only alternative we would have is representing time progression with other dimensions like point color intensity or perhaps point diameter."
  },
  {
    "objectID": "posts/animationRescue/index.html",
    "href": "posts/animationRescue/index.html",
    "title": "Animation to explain coupled time-series",
    "section": "",
    "text": "I consider Edward E. Tufte one of the modern experts in data visualization. I attended one of his talks in Seattle in May 2019. All attendees walked away with a beautiful set of his most important books, while I left with the challenge of stuffing the set in my carry-on bag on the flight back to Calgary that night.\nAside from the pleasant experience and the wonderful books, I bring this up because Tufte introduces many clever and even beautiful examples of time series visualizations in his book “The Visual Display of Quantitative Information” ([1]). He claims that visual excellence is achieved when one can convey an idea to an observer without taking too long, using the least amount of ink and printed space. This implies cramming the most information possible with the least use of resources without obscuring meaning or confusing the main idea.\nOne of the time-series examples is a facet grid plot representing the evolution of the rate of unemployment and inflation in several countries, see the figure below. The term “facet grid” is used in ggplot2 lingo to refer to a table of plots comparing different subgroups within the data. This is not your traditional time series plot.\nRecently I was preparing a CalgaryR meetup presentation and reading the book by Hadley Wickham, the creator of ggplot2 ([2]). To my surprise, the last example introducing the concept of plot geoms, just before presenting facet grids, matched the idea used in the subplots of the example mentioned by Tufte. I realized then that I had found a use case for animation to improve this visualization in the era of digital media. Allow me to explain in this post."
  },
  {
    "objectID": "posts/animationRescue/index.html#the-problem-statement",
    "href": "posts/animationRescue/index.html#the-problem-statement",
    "title": "Animation to explain coupled time-series",
    "section": "The problem statement",
    "text": "The problem statement\nTo find a solution, let’s first highlight the problem. To do so we will formulate a research question and gradually build up a graphical representation to answer it. To do this, we will walk through the example from Hadley Wickham’s book on ggplot2 ([2]).\nWe want to show that by pushing the tools to their maximum we reach a climax, a point where we are constrained by the lack of motion. At that point in the story, we will have the right context to present animation to uncover a hidden feature of our data set.\nThe problem is how confusing it can be to add time as a third variable in a plot where each point is the intersection of two variables at different times.\nIt is simple to represent a time series by drawing the variable on one axis and time on the other. Tufte has many creative examples from several authors using this principle in his book. The difficulty becomes visualizing two of those time series on the same graph.\nA possible research question is what has been tried to address this limitation? And also, is there a novel approach to add visual dimensions to a flat X-Y plot without sacrificing visual excellence?"
  },
  {
    "objectID": "posts/animationRescue/index.html#the-economics-data-set",
    "href": "posts/animationRescue/index.html#the-economics-data-set",
    "title": "Animation to explain coupled time-series",
    "section": "The economics data set",
    "text": "The economics data set\nWith the problem statement out of the way, let’s move on to the .\nThese examples are re-used from section 2.6.5 of https://ggplot2-book.org/getting-started#sec-line.\nThe data set called economics from the ggplot2 package, has employment statistics on the US measured over the last 40 years up until 2015.\nHere is a brief look at the first 5 out of 574 rows of the dataframe economics.\n\ndata &lt;- head(economics, n=5)\nknitr::kable(data)\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n1967-07-01\n506.7\n198712\n12.6\n4.5\n2944\n\n\n1967-08-01\n509.8\n198911\n12.6\n4.7\n2945\n\n\n1967-09-01\n515.6\n199113\n11.9\n4.6\n2958\n\n\n1967-10-01\n512.2\n199311\n12.9\n4.9\n3143\n\n\n1967-11-01\n517.4\n199498\n12.8\n4.7\n3066"
  },
  {
    "objectID": "posts/animationRescue/index.html#visualizing-the-unemployment-rate",
    "href": "posts/animationRescue/index.html#visualizing-the-unemployment-rate",
    "title": "Animation to explain coupled time-series",
    "section": "Visualizing the Unemployment Rate",
    "text": "Visualizing the Unemployment Rate\nLet’s first make a simple time series plot of the unemployment rate. This is a continuous variable that is computed with the ratio unemploy/pop.\nIn ggplot2 a frame defines the first mapping from variables to a space where the data will be represented. It is created with the function aes(). The obvious frame for this plot is defined by the two variables date and unemploy / pop. They are mapped to the x and y coordinates of a 2-D plane. The glyphs drawn over this frame will be lines between the data points located in the frame, they are created with the function geom_line(). This function defines a layer over the frame.\n\nlibrary(plotly)\ng &lt;- ggplot(data = economics, mapping = aes(x = date, y = unemploy / pop)) +\n  geom_line()\ng &lt;- ggplotly(g)\ng\n\n\n\n\n\nTechnically speaking unemploy / pop represents the “population rate of unemployment as a fraction of the population able to work that is unemployed”, (https://www.bls.gov/cps/cps_htgm.htm#definitions)"
  },
  {
    "objectID": "posts/animationRescue/index.html#visualizing-the-unemployment-median-duration-in-weeks",
    "href": "posts/animationRescue/index.html#visualizing-the-unemployment-median-duration-in-weeks",
    "title": "Animation to explain coupled time-series",
    "section": "Visualizing the unemployment median duration in weeks",
    "text": "Visualizing the unemployment median duration in weeks\nAnother variable called uempmed from the same dataset tracks the median length of time in weeks of unemployment.\n\nlibrary(plotly)\ng &lt;- ggplot(economics, aes(date, uempmed)) +\n  geom_line()\ng &lt;- ggplotly(g)\ng\n\n\n\n\n\nFrom these two plots one can observe the recent trend towards longer median unemployment time in the decade of 2010. There are also cycles of between 5 and 10 years of peak unemployment rates.\nAn interesting question is how these two time series correlate over time. Are there interactions between these two variables that we could observe in one plot?"
  },
  {
    "objectID": "posts/animationRescue/index.html#visualizing-both-variables-in-the-same-plot",
    "href": "posts/animationRescue/index.html#visualizing-both-variables-in-the-same-plot",
    "title": "Animation to explain coupled time-series",
    "section": "Visualizing both variables in the same plot",
    "text": "Visualizing both variables in the same plot\nIn ggplot2, the frame for a representation that shows both variables on an line plot can be defined by a mapping of each variable to the x and y coordinates of the plane. We can create two types of glyphs over it: one is points shown by a layer defined by geom_point to show the location of the variables at a point in time. The other type of glyph is lines to show the sequential trajectory, ordered by time, from one point to the next. This is captured by the layer geom_path. The figure below shows such a graph.\n\nlibrary(plotly)\ng &lt;- ggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path() +\n  geom_point()\ng &lt;- ggplotly(g)\ng\n\n\n\n\n\nIt is hard to understand the direction of time from the lines alone. For example, it is difficult to visualize where the first, the last, or any years in between have happened.\nThis can be addressed by adding a mapping from the property colour to the variable year in the layer geom_point. R uses a default colour scale to assign specific colours from a colour palette to years.\nThe ggplot2 package defines the function aes() to create this many to many mapping.\n\nlibrary(plotly)\nyear &lt;- function(x) as.POSIXlt(x)$year + 1900\ng &lt;- ggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path(colour = \"grey50\") +\n  geom_point(aes(colour = year(date)))\ng &lt;- ggplotly(g)\ng\n\n\n\n\n\nThe layer geom_path has a mapping from each line created between points to the same colour value indicated by the specification “grey50”. The syntax does not require the use of the aes() function. It is a many to one mapping.\nThis plot is a good attempt at representing the time dimension with a varying shade of colour. This is unsatisfactory because the lines get too tangled, making the direction of time unclear. This looks eerily similar to the example Tufte refers to in his book, the difference is that we don’t print years near some of the dots. Instead we chose to use the shade of blue in the points as a way to convey information about the year."
  },
  {
    "objectID": "posts/animationRescue/index.html#animation-to-the-rescue",
    "href": "posts/animationRescue/index.html#animation-to-the-rescue",
    "title": "Animation to explain coupled time-series",
    "section": "Animation to the rescue",
    "text": "Animation to the rescue\nWe can get a more sophisticated visualization by using animation to explain how the two variables change simultaneously as time passes. In the following plot, the values of unemployment rate and median unemployment length in weeks are displayed for every year. By pressing the PLAY button, one sees the points for each year over the line trajectory, from beginning to end. One can use the slider to visualize the position of the variables for any given year.\n\nlibrary(plotly)\nyear &lt;- function(x) as.POSIXlt(x)$year + 1900\np &lt;- ggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path(colour = \"grey75\") +\n  geom_point(aes(colour = year(date), frame = year(date)))\n\nfig &lt;- ggplotly(p)\n\nfig &lt;- fig %&gt;% animation_opts(1000,\n                              easing = \"elastic\", \n                              redraw = FALSE )\nfig &lt;- fig %&gt;% animation_button(x = 0.05, xanchor = \"left\",\n                                y = 1.1, yanchor = \"top\")\nfig &lt;- fig %&gt;% animation_slider(currentvalue = list(prefix = \"YEAR \",\n                                                    font = list(color=\"red\")))\nfig\n\n\n\n\n\nFrom watching the motion of the annual data after pressing the Play button, one gets the sense that for the first 41 years the values of these two time series remained within the quadrant below the 15 week and to the left of 4% unemployment rate except for the years 1982 and 83. Then after 2009 the median unemployment length in weeks has increased over and above any value of the previous years in the USA according to this dataset.\nAt this point an economist might formulate the research question, what was the cause of this change in mean time to regain employment status? I would even suggest reviewing other available independent data sources, to confirm the existence of this trend.\nAs far as the exploratory work goes, this animation has achieved the introduction of a new dimension to represent the flow of time over the plane representing the two observed variables.\nBefore the digital era the only alternative we would have was representing time progression with other dimensions like point color intensity or perhaps point diameter.\n\nReferences\n\n\n[1] Tufte ER. The Visual Display of Quantitative Information. Second Ed. Graphics Press; 2001.\n\n\n[2] Wickham H. ggplot2: Elegant Graphics for Data Analysis. Second Ed. Springer-Verlag New York; 2016."
  },
  {
    "objectID": "posts/AnimationWorkflow /index.html",
    "href": "posts/AnimationWorkflow /index.html",
    "title": "How to create a GIF file from individual images",
    "section": "",
    "text": "Do you ever feel like a plain graph is not sufficient to explain some trend in your data or the solution of a mathematical model? For those times, generating animations can be just what you need. They can also become visualization aids during data exploration or a means to explain to yourself and others observed or simulated results.\nThis is by no means an exhaustive list of use cases, however, they are pretty common and their impact can be high. The deliverable is an embedded moving graph for your presentation or web content. After all, if an image is worth a thousand words then an animation should be worth a bit more.\nThis workflow is the basis to create the visualizations used in this LinkedIn post [1]\n\n\n\nAnimation from the post mentioned in [1]\n\n\n\n\n\n\n[1] Adames P. Expected Values and Variance 2021."
  },
  {
    "objectID": "posts/AnimationWorkflow /index.html#why-doing-this",
    "href": "posts/AnimationWorkflow /index.html#why-doing-this",
    "title": "How to create a GIF file from individual images",
    "section": "",
    "text": "Do you ever feel like a plain graph is not sufficient to explain some trend in your data or the solution of a mathematical model? For those times, generating animations can be just what you need. They can also become visualization aids during data exploration or a means to explain to yourself and others observed or simulated results.\nThis is by no means an exhaustive list of use cases, however, they are pretty common and their impact can be high. The deliverable is an embedded moving graph for your presentation or web content. After all, if an image is worth a thousand words then an animation should be worth a bit more.\nThis workflow is the basis to create the visualizations used in this LinkedIn post [1]\n\n\n\nAnimation from the post mentioned in [1]\n\n\n\n\n\n\n[1] Adames P. Expected Values and Variance 2021."
  },
  {
    "objectID": "posts/AnimationWorkflow/index.html",
    "href": "posts/AnimationWorkflow/index.html",
    "title": "How to create a GIF file from individual images",
    "section": "",
    "text": "Do you ever feel like a plain graph is not sufficient to explain some trend in your data or the solution of a mathematical model? For those times, generating animations can be just what you need. They can also become visualization aids during data exploration or a means to explain observations to yourself and others.\nThis is by no means an exhaustive list of use cases, however, they are pretty common and their impact can be high. The deliverable is an embedded moving graph for your presentation or web content. After all, if an image is worth a thousand words then an animation should be worth a bit more.\nThis workflow is the basis to create the visualizations used in this LinkedIn post [1]\n\n\n\nAnimation from the LinkedIn post referred to by [1]\n\n\nIn that post this animation was created using a simple but effective workflow.\n\nRun a numerical model using simulated input\nThe output of each run is used to construct a plot.\nEach plot is saved to a PNG file.\nThen a GIF file is constructed with all the jpeg files.\n\nTo illustrate this workflow we will use simulation. Other use cases may be sensor data or any observed data.\n\n\nWhen applying this algorithm to a simulation, the input in Step 1 above usually comes from a pseudo random number generator in your language of choice. In this case I used the following R code to generate the data before constructing the plots and the animation. The code computes the cumulative profit or loss from repeatedly playing the same wager for a very long time. Eventually the expected result should tend to zero for either wager 3 or 4.\n\nlibrary(lattice)\n\nnumsimulations = 20000\nnumframes = 30\n  \nset.seed(1892)\ndievalues = seq(1,6)\n\nfor (i in 1:numframes){\n  \n  die3 = sample(dievalues, numsimulations, replace=T)\n  die4 = sample(dievalues, numsimulations, replace=T)\n  \n  profit3 = 300*( die3&gt;3 ) - 300*( die3&lt;=3 )\n  profit4 = 150*( die4&gt;2 ) - 300*( die4&lt;=2 )\n  \n  runningprofit3 = cumsum(profit3) / seq(1, numsimulations)\n  runningprofit4 = cumsum(profit4) / seq(1, numsimulations)\n  \n  df3 &lt;- data.frame(wager=rep(3,length(runningprofit3)), runningprofit=runningprofit3, tries=seq(1,numsimulations))\n  df4 &lt;- data.frame(wager=rep(4,length(runningprofit4)), runningprofit=runningprofit4, tries=seq(1,numsimulations))\n  df &lt;- rbind(df3, df4)\n  \n  # more code follows here to generate the plots and the PNG files\n}\n\nLine 3 sets the number of simulation points to 20,000 so we get sharp plots. Line 5 sets the number of frames that the animation will have. Line 6 defines a fixed value for reproducible results from the pseudo random number generator used by the sample function that will be used in lines 11 and 12. Line 7 defines the 6 possible results of rolling a single die. Line 9 starts a loop to generate the frames of the animation. In lines 11 and 12 two vectors of 20,000 elements are created, each one simulates one roll of a fair die. The code in lines 14 and 15 create the two vectors of 20,000 elements, each represents the profit resulting from rolling the die once. Each throw is an independent event, thus their individual profit can be computed with the input vectors die3 and die4.\nLines 17 and 18 compute the cumulative profit or loss resulting from sequentially realizing the 20,000 wagers sequentially.\nThe following code inspects some of the vectors generated above for each frame. R is a natively vectorized language, therefore no special libraries are necessary. The library import statement in line 1 is for plot generation in a latter step.\n\nlength(runningprofit3)\n#&gt; [1] 20000\n\nhead(runningprofit3)\n#&gt; [1] -300    0 -100    0   60  100\ntail(runningprofit3)\n#&gt; [1] -2.925731 -2.910582 -2.895434 -2.880288 -2.895145 -2.880000\nhead(runningprofit4)\n#&gt; [1] -300.0  -75.0    0.0   37.5   60.0   75.0\ntail(runningprofit4)\n#&gt; [1] -1.822956 -1.815363 -1.830275 -1.845185 -1.860093 -1.852500\n\nOne can see how the initial profit or loss can be large, however the net value tends to be near zero after many repetitions.\n\n\n\nThe graphic package Trellis is designed to work on data presented in the so-called long format. The idea is that the dataframe with all the data has a column representing a categorical variable representing the subgroup the data belongs to. This is a fundamental idea behind this package. This plotting of many subgroups in a grid-like pattern is what is called faceting in ggplot2 terms.\n\n  df3 &lt;- data.frame(wager=rep(3,length(runningprofit3)), runningprofit=runningprofit3, tries=seq(1,numsimulations))\n  df4 &lt;- data.frame(wager=rep(4,length(runningprofit4)), runningprofit=runningprofit4, tries=seq(1,numsimulations))\n  df &lt;- rbind(df3, df4)\n\nIn lines 1 and 2 above, separate data frames each of 20,000 rows are created. In line 3 they are stacked vertically together to form a single data structure with 40,000 rows.\nThe following calls to the first and last three lines of the dataframe illustrate the long format of the data. The column wager represent the subgroup each row belongs to: wager 3 or 4.\n\nhead(df, n = 3)\n#&gt;   wager runningprofit tries\n#&gt; 1     3          -300     1\n#&gt; 2     3             0     2\n#&gt; 3     3          -100     3\ntail(df, n = 3)\n#&gt;       wager runningprofit tries\n#&gt; 39998     4     -1.845185 19998\n#&gt; 39999     4     -1.860093 19999\n#&gt; 40000     4     -1.852500 20000\n\nWe are ready to plot using the lattice plotting package. The following is the function that creates and returns such a lattice plot object. It receives two arguments, the dataframe in long form and a list of arguments to configure the plot.\n\n# Create a lattice xy plot object in memory ------------------------------------------------\n# Purpose:        to construct a valid lattice log_x-y plot of one or more series \n# Description:    The argument `the_data_frame` is in long form, where each row has data\n#                 for a sub-group. The list of arguments to construct the plot are:\n#                 1. the name of the variable that defines the subgroups, called subgroup_variable\n#                 2. a list of text labels for title, x and y axis, called text_labels_for_plot\n#                 3. a vector of the min and max values to use for the y axis, min_max_y_to_plot\n#                 4. a vector of text descriptions for every series to plot, or NULL, called subgroup_descriptions\ncreate_xyplot &lt;- function(the_data_frame, \n                          args_to_plot) {\n    # unpack arguments\n    the_subgroup_variable_name &lt;- args_to_plot[['subgroup_variable']]\n    the_text_plot_labels &lt;- args_to_plot[['text_labels_for_plot']]\n    min_max_y_to_plot &lt;- args_to_plot[['min_max_y_to_plot']]\n    the_subgroup_descriptions &lt;- args_to_plot[['subgroup_descriptions']]\n    \n    # setup values for plotting\n    group_labels &lt;- as.vector(unique(the_data_frame[the_subgroup_variable_name]))\n    wager_labels &lt;- as.vector(sapply( group_labels, FUN = function(x) {paste0(\"Wager \", x)}))\n    if (is.null(the_subgroup_descriptions)) {\n        the_subgroup_descriptions &lt;- wager_labels\n    }\n    wagers_vector &lt;- the_data_frame[[the_subgroup_variable_name]]\n\n    max_x_value &lt;- length(wagers_vector[wagers_vector==group_labels[[the_subgroup_variable_name]][1]])\n\n    xyplot(\n        runningprofit ~ tries,\n        data = the_data_frame,\n        groups = wager,\n        par.settings = list(superpose.line = list(\n            col = c(\"blue\", \"red\", \"green\", \"yellow\", \"brown\", \"cyan\"),\n            lwd = 1\n        )),\n        auto.key = list(\n            space = \"top\",\n            columns = 2,\n            text = the_subgroup_descriptions,\n            title = the_text_plot_labels[['title']],\n            cex.title = 2,\n            lines = TRUE,\n            points = FALSE\n        ),\n        xlab = the_text_plot_labels[['x_label']],\n        xlim = c(1, max_x_value),\n        scales = list(\n            cex = c(1.1, 1.1),            # increase font size\n            x = list(log = T),            # log scale for x-axis\n            y = list(log = F),\n            alternating = 1,              # axes labels left/bottom\n            tck = c(1, 0)\n        ),                                # ticks only with labels\n        ylab = the_text_plot_labels[['y_label']],\n        ylim = min_max_y_to_plot,\n        type = c(\"l\"),\n        panel = panel.superpose,\n        panel.groups = function(x, y, group.number, ...) {\n            panel.abline(h = y[which(y == 0.0)],\n                         lty = \"dotted\",\n                         col = \"black\")\n            panel.grid(v = -1,\n                       h = -1,\n                       lty = 3)\n            xt &lt;- x[x == log(min(x) + 1)] # find x coordinate for first point\n            yt &lt;- y[x == min(x)] # find y coordinate for first point\n            panel.text(xt,\n                       yt,\n                       labels = wager_labels[group.number],\n                       pos = 4,  # show labels on right side\n                       ...)\n            panel.xyplot(x, y, ...)\n        }\n    )\n}\n\nAn important detail of the lattice package is that it allows the superposition of the two subgroups: wager 3 and 4 thanks to the panel.superpose and the lambda function passed to the argument panel.groups. This panel type allows to paint the two different sub-groups on the same axis using the provided function. This function receives the group identifier when called once for each subgroup. In this particular case it adds programmatically a label to the first point of the series. The panel.superpose allows the positioning of the line plots corresponding to the two series on the same x-y grid so we can compare them visually.\n\n\n\nThe plot object generated in the previous step lives in the computer memory as an R object while we run the R session. We want to persist it in the file system as a PNG file. To achieve this goal we use the functions png and print.\nIn the code snipped below, I call the png function in line 1 to set the PNG file writer as the output device for subsequent calls to print images. Line ** 3** creates the arguments expected by the function as one list. The elements of the list are named so their order does not matter. Only the subgroup_descriptions can be NULL. Their function is explained by their name. In line 11 the lattice plot is created in memory and returned immediately to be assigned to the variable pp. The function xyplot comes from the package lattice. Line 14 passes the lattice object pp to the function print to create the PNG file using the name convention given in line 1. Multiple calls to print will create new PNG files adding one each timne to the numeric value represented by the %02d that is part of the file name.\n\npng(file=\"simwager%02d.png\", width=600, height=400)\n\nargs_to_plot &lt;- list( subgroup_variable = 'wager',\n                      subgroup_descriptions = c(\"Wager3 = 3(die&gt;3) - 3(die&lt;=3)\",\n                        \"Wager 4 = 1.5(die&gt;2) - 3(die&lt;=2)\"),\n                      text_labels_for_plot = list(title=\"Running profits from two different wagers\",\n                             x_label=\"Number of tries\",\n                             y_label=\"Cummulative profit\"),\n                      min_max_y_to_plot = c(-350, 350))\n\npp &lt;- create_xyplot(df, \n                    args_to_plot)\n\nprint(pp)\n\ndev.off()\n#&gt; png \n#&gt;   2\n\nThis code creates a file called simwager01.png in the current working directory for the R session, as shown below.\n\n\n\nPlot produced by the previous code chunk in the current working directory.\n\n\nIf this sequence of calls are part of an iteration loop, several PNG files will be created, each with an monotonically increased serial number as part of its name. For an explanation of how it works see the r-documentation for the function png\nI left some details out of the code shown at the beginning of this post because it would have been a distraction then. We must create a directory called animations from the project root path and then make it the current working directory as the first action in the script. By doing this all the file actions occur in the same folder. That is, the PNG files required for one animation are first created and then deleted after they are used in the same directory where the animated GIF file is created.\nThe following code accomplishes creating and changing into this directory.\n\nif (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(\"here\")\n\nsuppressWarnings(my_proj_path &lt;- here())\n\nif (!file.exists(file.path(my_proj_path,\"animations\"))) {\n  dir.create(file.path(my_proj_path, \"animations\"))\n}\nsetwd(file.path(my_proj_path, \"animations\"))\n\n\n\n\nWhat we have up to this point is a directory with PNG files. The implicit assumption is that the order each PNG file is to be used to create the animation is implicit in its name. I will use a program to render an animated file in GIF format from the PNG files using the command line. The renderer used is convert from the package ImageMagik, publicly available as binaries for download for Linux, Mac and Windows, this example was run on Ubuntu Linux 24.04, version ImageMagick 6.9.12-98 Q16 x86_64 18038.\nTo call convert we make an operating system call from the R script. The arguments assume that all PNG files in the current directory are meant to be part of the GIF output. The order of the frames for the animation come from the digits included in the file names using the %02d in the call to the function png. Finally the PNG files are deleted from the folder.\n\nsystem(\"/usr/bin/convert -delay 40 *.png wager_comp_sim.gif\")\n\nfile.remove(list.files(pattern=\".png\"))\n\nThe delay argument sets the time pause between frames in centiseconds. This makes the frame rate approximately 2.5 frames per second.\nThe package gganimate, [2], works under the same workflow explained here but it gives the flexibility to choose renderer and the file format of the final animation."
  },
  {
    "objectID": "posts/AnimationWorkflow/index.html#why-doing-this",
    "href": "posts/AnimationWorkflow/index.html#why-doing-this",
    "title": "How to create a GIF file from individual images",
    "section": "",
    "text": "Do you ever feel like a plain graph is not sufficient to explain some trend in your data or the solution of a mathematical model? For those times, generating animations can be just what you need. They can also become visualization aids during data exploration or a means to explain observations to yourself and others.\nThis is by no means an exhaustive list of use cases, however, they are pretty common and their impact can be high. The deliverable is an embedded moving graph for your presentation or web content. After all, if an image is worth a thousand words then an animation should be worth a bit more.\nThis workflow is the basis to create the visualizations used in this LinkedIn post [1]\n\n\n\nAnimation from the LinkedIn post referred to by [1]\n\n\nIn that post this animation was created using a simple but effective workflow.\n\nRun a numerical model using simulated input\nThe output of each run is used to construct a plot.\nEach plot is saved to a PNG file.\nThen a GIF file is constructed with all the jpeg files.\n\nTo illustrate this workflow we will use simulation. Other use cases may be sensor data or any observed data.\n\n\nWhen applying this algorithm to a simulation, the input in Step 1 above usually comes from a pseudo random number generator in your language of choice. In this case I used the following R code to generate the data before constructing the plots and the animation. The code computes the cumulative profit or loss from repeatedly playing the same wager for a very long time. Eventually the expected result should tend to zero for either wager 3 or 4.\n\nlibrary(lattice)\n\nnumsimulations = 20000\nnumframes = 30\n  \nset.seed(1892)\ndievalues = seq(1,6)\n\nfor (i in 1:numframes){\n  \n  die3 = sample(dievalues, numsimulations, replace=T)\n  die4 = sample(dievalues, numsimulations, replace=T)\n  \n  profit3 = 300*( die3&gt;3 ) - 300*( die3&lt;=3 )\n  profit4 = 150*( die4&gt;2 ) - 300*( die4&lt;=2 )\n  \n  runningprofit3 = cumsum(profit3) / seq(1, numsimulations)\n  runningprofit4 = cumsum(profit4) / seq(1, numsimulations)\n  \n  df3 &lt;- data.frame(wager=rep(3,length(runningprofit3)), runningprofit=runningprofit3, tries=seq(1,numsimulations))\n  df4 &lt;- data.frame(wager=rep(4,length(runningprofit4)), runningprofit=runningprofit4, tries=seq(1,numsimulations))\n  df &lt;- rbind(df3, df4)\n  \n  # more code follows here to generate the plots and the PNG files\n}\n\nLine 3 sets the number of simulation points to 20,000 so we get sharp plots. Line 5 sets the number of frames that the animation will have. Line 6 defines a fixed value for reproducible results from the pseudo random number generator used by the sample function that will be used in lines 11 and 12. Line 7 defines the 6 possible results of rolling a single die. Line 9 starts a loop to generate the frames of the animation. In lines 11 and 12 two vectors of 20,000 elements are created, each one simulates one roll of a fair die. The code in lines 14 and 15 create the two vectors of 20,000 elements, each represents the profit resulting from rolling the die once. Each throw is an independent event, thus their individual profit can be computed with the input vectors die3 and die4.\nLines 17 and 18 compute the cumulative profit or loss resulting from sequentially realizing the 20,000 wagers sequentially.\nThe following code inspects some of the vectors generated above for each frame. R is a natively vectorized language, therefore no special libraries are necessary. The library import statement in line 1 is for plot generation in a latter step.\n\nlength(runningprofit3)\n#&gt; [1] 20000\n\nhead(runningprofit3)\n#&gt; [1] -300    0 -100    0   60  100\ntail(runningprofit3)\n#&gt; [1] -2.925731 -2.910582 -2.895434 -2.880288 -2.895145 -2.880000\nhead(runningprofit4)\n#&gt; [1] -300.0  -75.0    0.0   37.5   60.0   75.0\ntail(runningprofit4)\n#&gt; [1] -1.822956 -1.815363 -1.830275 -1.845185 -1.860093 -1.852500\n\nOne can see how the initial profit or loss can be large, however the net value tends to be near zero after many repetitions.\n\n\n\nThe graphic package Trellis is designed to work on data presented in the so-called long format. The idea is that the dataframe with all the data has a column representing a categorical variable representing the subgroup the data belongs to. This is a fundamental idea behind this package. This plotting of many subgroups in a grid-like pattern is what is called faceting in ggplot2 terms.\n\n  df3 &lt;- data.frame(wager=rep(3,length(runningprofit3)), runningprofit=runningprofit3, tries=seq(1,numsimulations))\n  df4 &lt;- data.frame(wager=rep(4,length(runningprofit4)), runningprofit=runningprofit4, tries=seq(1,numsimulations))\n  df &lt;- rbind(df3, df4)\n\nIn lines 1 and 2 above, separate data frames each of 20,000 rows are created. In line 3 they are stacked vertically together to form a single data structure with 40,000 rows.\nThe following calls to the first and last three lines of the dataframe illustrate the long format of the data. The column wager represent the subgroup each row belongs to: wager 3 or 4.\n\nhead(df, n = 3)\n#&gt;   wager runningprofit tries\n#&gt; 1     3          -300     1\n#&gt; 2     3             0     2\n#&gt; 3     3          -100     3\ntail(df, n = 3)\n#&gt;       wager runningprofit tries\n#&gt; 39998     4     -1.845185 19998\n#&gt; 39999     4     -1.860093 19999\n#&gt; 40000     4     -1.852500 20000\n\nWe are ready to plot using the lattice plotting package. The following is the function that creates and returns such a lattice plot object. It receives two arguments, the dataframe in long form and a list of arguments to configure the plot.\n\n# Create a lattice xy plot object in memory ------------------------------------------------\n# Purpose:        to construct a valid lattice log_x-y plot of one or more series \n# Description:    The argument `the_data_frame` is in long form, where each row has data\n#                 for a sub-group. The list of arguments to construct the plot are:\n#                 1. the name of the variable that defines the subgroups, called subgroup_variable\n#                 2. a list of text labels for title, x and y axis, called text_labels_for_plot\n#                 3. a vector of the min and max values to use for the y axis, min_max_y_to_plot\n#                 4. a vector of text descriptions for every series to plot, or NULL, called subgroup_descriptions\ncreate_xyplot &lt;- function(the_data_frame, \n                          args_to_plot) {\n    # unpack arguments\n    the_subgroup_variable_name &lt;- args_to_plot[['subgroup_variable']]\n    the_text_plot_labels &lt;- args_to_plot[['text_labels_for_plot']]\n    min_max_y_to_plot &lt;- args_to_plot[['min_max_y_to_plot']]\n    the_subgroup_descriptions &lt;- args_to_plot[['subgroup_descriptions']]\n    \n    # setup values for plotting\n    group_labels &lt;- as.vector(unique(the_data_frame[the_subgroup_variable_name]))\n    wager_labels &lt;- as.vector(sapply( group_labels, FUN = function(x) {paste0(\"Wager \", x)}))\n    if (is.null(the_subgroup_descriptions)) {\n        the_subgroup_descriptions &lt;- wager_labels\n    }\n    wagers_vector &lt;- the_data_frame[[the_subgroup_variable_name]]\n\n    max_x_value &lt;- length(wagers_vector[wagers_vector==group_labels[[the_subgroup_variable_name]][1]])\n\n    xyplot(\n        runningprofit ~ tries,\n        data = the_data_frame,\n        groups = wager,\n        par.settings = list(superpose.line = list(\n            col = c(\"blue\", \"red\", \"green\", \"yellow\", \"brown\", \"cyan\"),\n            lwd = 1\n        )),\n        auto.key = list(\n            space = \"top\",\n            columns = 2,\n            text = the_subgroup_descriptions,\n            title = the_text_plot_labels[['title']],\n            cex.title = 2,\n            lines = TRUE,\n            points = FALSE\n        ),\n        xlab = the_text_plot_labels[['x_label']],\n        xlim = c(1, max_x_value),\n        scales = list(\n            cex = c(1.1, 1.1),            # increase font size\n            x = list(log = T),            # log scale for x-axis\n            y = list(log = F),\n            alternating = 1,              # axes labels left/bottom\n            tck = c(1, 0)\n        ),                                # ticks only with labels\n        ylab = the_text_plot_labels[['y_label']],\n        ylim = min_max_y_to_plot,\n        type = c(\"l\"),\n        panel = panel.superpose,\n        panel.groups = function(x, y, group.number, ...) {\n            panel.abline(h = y[which(y == 0.0)],\n                         lty = \"dotted\",\n                         col = \"black\")\n            panel.grid(v = -1,\n                       h = -1,\n                       lty = 3)\n            xt &lt;- x[x == log(min(x) + 1)] # find x coordinate for first point\n            yt &lt;- y[x == min(x)] # find y coordinate for first point\n            panel.text(xt,\n                       yt,\n                       labels = wager_labels[group.number],\n                       pos = 4,  # show labels on right side\n                       ...)\n            panel.xyplot(x, y, ...)\n        }\n    )\n}\n\nAn important detail of the lattice package is that it allows the superposition of the two subgroups: wager 3 and 4 thanks to the panel.superpose and the lambda function passed to the argument panel.groups. This panel type allows to paint the two different sub-groups on the same axis using the provided function. This function receives the group identifier when called once for each subgroup. In this particular case it adds programmatically a label to the first point of the series. The panel.superpose allows the positioning of the line plots corresponding to the two series on the same x-y grid so we can compare them visually.\n\n\n\nThe plot object generated in the previous step lives in the computer memory as an R object while we run the R session. We want to persist it in the file system as a PNG file. To achieve this goal we use the functions png and print.\nIn the code snipped below, I call the png function in line 1 to set the PNG file writer as the output device for subsequent calls to print images. Line ** 3** creates the arguments expected by the function as one list. The elements of the list are named so their order does not matter. Only the subgroup_descriptions can be NULL. Their function is explained by their name. In line 11 the lattice plot is created in memory and returned immediately to be assigned to the variable pp. The function xyplot comes from the package lattice. Line 14 passes the lattice object pp to the function print to create the PNG file using the name convention given in line 1. Multiple calls to print will create new PNG files adding one each timne to the numeric value represented by the %02d that is part of the file name.\n\npng(file=\"simwager%02d.png\", width=600, height=400)\n\nargs_to_plot &lt;- list( subgroup_variable = 'wager',\n                      subgroup_descriptions = c(\"Wager3 = 3(die&gt;3) - 3(die&lt;=3)\",\n                        \"Wager 4 = 1.5(die&gt;2) - 3(die&lt;=2)\"),\n                      text_labels_for_plot = list(title=\"Running profits from two different wagers\",\n                             x_label=\"Number of tries\",\n                             y_label=\"Cummulative profit\"),\n                      min_max_y_to_plot = c(-350, 350))\n\npp &lt;- create_xyplot(df, \n                    args_to_plot)\n\nprint(pp)\n\ndev.off()\n#&gt; png \n#&gt;   2\n\nThis code creates a file called simwager01.png in the current working directory for the R session, as shown below.\n\n\n\nPlot produced by the previous code chunk in the current working directory.\n\n\nIf this sequence of calls are part of an iteration loop, several PNG files will be created, each with an monotonically increased serial number as part of its name. For an explanation of how it works see the r-documentation for the function png\nI left some details out of the code shown at the beginning of this post because it would have been a distraction then. We must create a directory called animations from the project root path and then make it the current working directory as the first action in the script. By doing this all the file actions occur in the same folder. That is, the PNG files required for one animation are first created and then deleted after they are used in the same directory where the animated GIF file is created.\nThe following code accomplishes creating and changing into this directory.\n\nif (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(\"here\")\n\nsuppressWarnings(my_proj_path &lt;- here())\n\nif (!file.exists(file.path(my_proj_path,\"animations\"))) {\n  dir.create(file.path(my_proj_path, \"animations\"))\n}\nsetwd(file.path(my_proj_path, \"animations\"))\n\n\n\n\nWhat we have up to this point is a directory with PNG files. The implicit assumption is that the order each PNG file is to be used to create the animation is implicit in its name. I will use a program to render an animated file in GIF format from the PNG files using the command line. The renderer used is convert from the package ImageMagik, publicly available as binaries for download for Linux, Mac and Windows, this example was run on Ubuntu Linux 24.04, version ImageMagick 6.9.12-98 Q16 x86_64 18038.\nTo call convert we make an operating system call from the R script. The arguments assume that all PNG files in the current directory are meant to be part of the GIF output. The order of the frames for the animation come from the digits included in the file names using the %02d in the call to the function png. Finally the PNG files are deleted from the folder.\n\nsystem(\"/usr/bin/convert -delay 40 *.png wager_comp_sim.gif\")\n\nfile.remove(list.files(pattern=\".png\"))\n\nThe delay argument sets the time pause between frames in centiseconds. This makes the frame rate approximately 2.5 frames per second.\nThe package gganimate, [2], works under the same workflow explained here but it gives the flexibility to choose renderer and the file format of the final animation."
  },
  {
    "objectID": "posts/AnimationWorkflow/index.html#conclusion",
    "href": "posts/AnimationWorkflow/index.html#conclusion",
    "title": "How to create a GIF file from individual images",
    "section": "Conclusion",
    "text": "Conclusion\nThe basic workflow for the creation of a GIF animated file has been presented with luxury of detail. One has to consider four basic steps: organize the data whereas it is observed or simulated. Then create a meaningful plot that adresses the research question. Then create multiple PNG files and finally create the GIF file from the intermediary PNG files.\nThe complete code for this example can be found in the GitHub repo: wagers\n\nReferences\n\n\n[1] Adames P. Expected Values and Variance 2021.\n\n\n[2] Pedersen TL, Robinson D. Gganimate: A grammar of animated graphics. 2024."
  }
]