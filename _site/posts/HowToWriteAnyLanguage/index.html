<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pablo Adames">
<meta name="dcterms.date" content="2025-01-21">

<title>pablo adames - How to process any text with Unicode</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">pablo adames</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/padames" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://stackoverflow.com/users/1585486/pablo-adames" rel="" target=""><i class="bi bi-stack-overflow" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/pablo-adames-87149711/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">How to process any text with Unicode</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">text</div>
                <div class="quarto-category">C++</div>
                <div class="quarto-category">Unicode</div>
                <div class="quarto-category">Rust</div>
                <div class="quarto-category">R</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Pablo Adames </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 21, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="text-is-everywhere" class="level2">
<h2 class="anchored" data-anchor-id="text-is-everywhere">Text is everywhere</h2>
<p>Chatbots, web pages, and stand-alone applications display information on the screens of our cell phones, home and office computers, at airports, bus and train stations. The text used in these scenarios enables clear communication. Text is not impeded by sound or obstructed by environmental noise and can deliver impact and meaning through semantically dense symbols reinforced by other visual or aural cues.</p>
<p>Text and written human language are, at their core, technologies developed to build and transmit culture. Accurate textual information is critical in international trade, e-commerce, and customer-facing software. It is safe to say that text has a fundamental role in sustaining our civilization.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://neuroflash.com/wp-content/uploads/2022/09/feature-image-automatic-text-editor-online.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Image credit: https://neuroflash.com/blog/automatic-text-editor-online/</figcaption>
</figure>
</div>
</section>
<section id="what-is-text-anyway" class="level2">
<h2 class="anchored" data-anchor-id="what-is-text-anyway">What is text anyway?</h2>
<p>To narrow the scope of this post to a manageable size, let’s constrain the answer to the world of computer languages. These are used to tell computers what to do when they receive data.</p>
<p>Computer programming starts by writing instructions in a text editor. The characters used to form those instructions were initially called the ASCII characters. These characters conveniently reflected the characters of the English alphabet plus the Arabic numerals and exclamation and punctuation marks.</p>
<p>In this context, text is used for two purposes. One is to write human-readable instructions for a computer to perform a task, the other is to be the data for the instructions to act upon.</p>
</section>
<section id="how-do-we-use-text-as-code" class="level2">
<h2 class="anchored" data-anchor-id="how-do-we-use-text-as-code">How do we use text as code?</h2>
<p>The instructions that a computer program are made of have to be interpreted and then transformed into machine-readable code before the machine can execute them. The first step implies parsing the text into functional parts: line breaks, plain data, commands, operators, variable and function names.</p>
<p>The next step is to put those components into an abstract syntax tree (AST) that represents the program. The AST is then further converted into bite code instructions for a run time or into machine instructions to be executed by the operating system scheduler in a process under its supervision, or even directly in to the microchip clock scheduler of a single board computer in the case of real time embedded systems.</p>
<!-- Everybody benefits from using text instead of programming directly using the instructions of the operating system or the bite code commands. Somehow using ASCII makes programming a computer a skill similar to learning one of the human languages. However, bias always favours the English-speaking programmer who knows how English reads. -->
<!-- Accepting the historical facts, let's dive into the ASCII character set. Its purpose is for programmers to encode rules that control the computer as it consumes input and produces output. We call these rules the program's logic. -->
<p>The input to and output from the program we call data. Digital computers natively process only zeros and ones. The text, images and sound supplied to a computer must be transformed first into a sequence of these two values.</p>
<p>Text as code is handled relatively well with a small character set. How about the handling of text, images, and sound as data?</p>
</section>
<section id="entering-text-encoding" class="level2">
<h2 class="anchored" data-anchor-id="entering-text-encoding">Entering text encoding</h2>
<p>Restraining myself to write about text only, I am ready to discuss the transformation of what we see as text in our preferred language into bits. A computer program must discern what part of those zeros and ones represent text and put together a message to act on it, whether it is displaying it on a screen, writing to a database, or “launching the missiles”, so to speak. Welcome to text decoding and encoding.</p>
<p>The complexity of this subject arises from the fact that human communication occurs within rich, dynamic, and diverse cultural contexts. Tradition, convention, identity, and art influence the glyphs and alphabets used to articulate words, sentences and, ultimately, ideas in human languages. Furthermore, each written language has rules for what a sentence and a word are, the direction of writing, what punctuation is, etc. It is easy to imagine that text can be as diverse as the human groups that use it.</p>
<p>How do we address this complexity? We use text encoding that machines can understand automatically and unequivocally. The accepted encoding standard is called Unicode. I will quote directly from the Unicode standard definition #51 <span class="citation" data-cites="uni16:emoji">[<a href="#ref-uni16:emoji" role="doc-biblioref">1</a>]</span>.</p>
<blockquote class="blockquote">
<p>Unicode is the foundation for text in all modern software: it’s how all mobile phones, desktops, and other computers represent the text of every language.</p>
</blockquote>
<p>A good source of interesting information on Unicode can be found in the web page called the <a href="https://www.unifont.org/unicodeprimer/">Unicode Primer</a>. Only to give an idea of an interpretation of the 1,112,064 valid Unicode values or code points, have a squinting look at an image at of the Unifont character map. Just for context the ASCII characters fit in less than the first full row on this table.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://free-images.com/or/8728/unifont_full_map_png.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 1. The Unifont full charcater map. Image Credit: https://free-images.com/or/8728/unifont_full_map_png.png</figcaption>
</figure>
</div>
<p>A font table like the one above is needed to render the Unicode characters or glyphs from their numerical values. There are currently a total of 1,112,064 valid Unicode values or code points. These are scalar values represented in base-16 (using the digits and the letters A to F), their range of values can be seen in Table 1 below. The first 128 code points correspond to the original ASCII and yes you may try to go back to the Unifont table to find them on the first row.</p>
<p>Independent of the artistic design of the font, the Unicode values appear in official tables associated with the typographical or artistic rendition of the glyph they represent. Long before and after they are rendered to a screen or printer, each character is treated as a series of numbers.</p>
<p>The text encodings address the challenge of writing effectively in binary. Text consists of a sequence of characters, usually stored in contiguous memory. The encoding schema must also address the identification of character boundaries when all the program sees is endless zeros and ones.</p>
<section id="a-journey-from-text-to-bits-and-back" class="level3">
<h3 class="anchored" data-anchor-id="a-journey-from-text-to-bits-and-back">A Journey from text to bits and back</h3>
<p>To illustrate the modern context in which we process text let’s consider a chat application for customer support in a mobile device, see the Figure 2 below. Text is entered on the mobile device through a virtual keyboard, rendered on screen, transformed ultimately into a byte stream with an UTF-8 encoding and sent through the wire/air using Internet protocols. On the receiving end, the bytes of zeros and ones are decoded into UTF-8, further transformed if necessary, interpreted using the indicated language and then displayed on the computer screen of the Browser used by the Customer Support agent to interact with the customer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="text_journey.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 2. The journey of a text message entered in a chat application in a mobile device to its destination in a computer screen of a customer support agent. Text does the same journey in the opposite direction when the support agent responds.</figcaption>
</figure>
</div>
<p>Text encoding is a mapping from the code points to some efficient way to write text in binary. A fixed bit width for each character would simplify parsing characters within some text sequence and it would make character boundaries trivial to infer, however, it would waste much space when representing the small ASCII characters. On the other side if we choose a variable bit width then space would be saved with the small values but an end-of-character marker would be required, also adding extra space and complexity.</p>
<p>The common Unicode text encoding to write source code in modern computer languages is called UTF-8, it is the encoding used to store the text of almost the entirety of the web pages of the Internet. UTF stands for the Unicode Transformation Format <span class="citation" data-cites="enwiki:1268238400_">[<a href="#ref-enwiki:1268238400_" role="doc-biblioref">2</a>]</span>. This is a super set of the ASCII character set used in the first computer languages like COBOL, FORTRAN and BASIC.</p>
<table class="table-striped table-hover table">
<caption>Table 1. Code point to UTF-8 encoding, from <span class="citation" data-cites="convertcodes:encodeformats">[<a href="#ref-convertcodes:encodeformats" role="doc-biblioref">3</a>]</span></caption>
<colgroup>
<col style="width: 40%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Range of Code Points</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>From U+0000 to U007F</td>
<td>0yyyzzzz</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>From U+0080 to U+07FF</td>
<td>110xxxyy</td>
<td>10yyzzzz</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>From U+0800 to U+FFFF</td>
<td>1110wwww</td>
<td>10xxxxyy</td>
<td>10yyzzzz</td>
<td></td>
</tr>
<tr class="even">
<td>From U+010000 to U+10FFFF</td>
<td>11110uvv</td>
<td>10vvwwww</td>
<td>10xxxxyy</td>
<td>10yyzzzz</td>
</tr>
</tbody>
</table>
<p>The code values or code points in Table 1 have a corresponding multi-byte representation in UTF-8 form, the encoding has a variable number of bytes. How many bytes is encoded by the number of consecutive ones in the most significant digits of the first byte in a byte sequence: none means the current byte is sufficient to encode the character fully, that is, it fits in one byte, e.g.&nbsp;an ASCII character. One means the byte is part of a multi-byte sequence. Two means the byte marks the start of a character encoded in two bytes in total. Three and four ones mean the equivalent, the byte marks the beginning of characters represented by three and four bytes respectively, including the leading one. Table 2 shows examples of each one of these cases.</p>
<table class="table-striped table-hover table">
<caption>Table 2. Examples of UTF-8 bytes for characters in each of the ranges of Unicode points presented in Table 1.</caption>
<thead>
<tr class="header">
<th>Character</th>
<th>Code point</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>H</td>
<td>U+0048</td>
<td>01001000</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>á</td>
<td>U+00E1</td>
<td>11000011</td>
<td>10100001</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>ᜋ</td>
<td>U+170B</td>
<td>11100001</td>
<td>10011100</td>
<td>10001011</td>
<td></td>
</tr>
<tr class="even">
<td>🍇</td>
<td>U+01F347</td>
<td>11110000</td>
<td>10011111</td>
<td>10001101</td>
<td>10000111</td>
</tr>
</tbody>
</table>
<p>This means that there is no need for escape sequences to mark the boundary of a single encoded multi-byte character. It also mean there is no need of a special marker for characters boundaries in a sequence of many characters. In addition to that it isolates semantic representation from character identification. Unicode encoding takes care of character boundaries but semantic parsing takes care of instruction or operator boundary.</p>
</section>
</section>
<section id="trade-offs-of-choosing-a-unicode-encoding" class="level2">
<h2 class="anchored" data-anchor-id="trade-offs-of-choosing-a-unicode-encoding">Trade-offs of choosing a Unicode encoding</h2>
<p>The code points can be encoded in three forms: UTF-8, UTF-16 and UTF-32. Each encoding maps the code points to unique code unit sequences of variable length <span class="citation" data-cites="uni16:encodingforms">[<a href="#ref-uni16:encodingforms" role="doc-biblioref">4</a>]</span>. In particular, the larger code points need multiple single code units if using the code form UTF-8. Conversely they may fit into a single code unit if encoded in UTF-32. This happens because the width of the smallest code unit is 8, 16, or 32 bits respectively for each of the forms. See Table 3 below for a comparison of three different encodings for a text sentence using short and long code points.</p>
<table class="table-striped table-hover table">
<caption>Table 3. Unicode encoding of the sentence <code>Hello 🍇, 🍈!</code> from the website <a href="https://convertcodes.com/unicode-converter-encode-decode-utf/">Convert Codes</a></caption>
<thead>
<tr class="header">
<th>Encoding</th>
<th>Hexadecimal</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UTF-8</td>
<td>48 65 6c 6c 6f 20 f0 9f 8d 87 2c 20 f0 9f 8d 88 21</td>
</tr>
<tr class="even">
<td>UTF-16</td>
<td>0048 0065 006c 006c 006f 0020 d83c df47 002c 0020 d83c df48 0021</td>
</tr>
<tr class="odd">
<td>UTF-32</td>
<td>00000048 00000065 0000006c 0000006c 0000006f 00000020 0001f347 0000002c 00000020 0001f348 00000021</td>
</tr>
</tbody>
</table>
<p>The long code points for the fruit emojis occupy a single UTF-32 code unit, look at 0001f347 and 0001f348, <code>🍇</code> and <code>🍈</code> in Table 4 below. from the same table one sees how these long codes require two code units in UTF-16 and four in UTF-8. That means more processing to read and write as more code units are required.</p>
<p>The selection of a encoding form to map code points to code units forces a trade off between space and complexity. UTF-8 is very efficient for handling the smaller Unicode values while it is complex to handle the large ones. Conversely, UTF-32 is wasteful for storing the smaller values but simple for the higher ones.</p>
<p>Windows chose to use UTF-16 natively since the NT version. It is efficient for the Asian alphabets that require at least two code points in UTF-8 but one in UTF-16 for most of their characters.</p>
<p>Consider the following emojis, their Unicode values and their multi-byte representation in three different encodings:</p>
<table class="table-striped table-hover table">
<caption>Table 4. Food-fruit emoji codes and equivalent encoded representations</caption>
<colgroup>
<col style="width: 17%">
<col style="width: 15%">
<col style="width: 19%">
<col style="width: 17%">
<col style="width: 15%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>fruit emoji</th>
<th>name</th>
<th>Unicode point</th>
<th>UTF-8</th>
<th>UTF-16</th>
<th>UTF-32</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>🍇</td>
<td>grapes</td>
<td>U+1F347</td>
<td>f0 9f 8d 87</td>
<td>d83c udf47</td>
<td>0001f347</td>
</tr>
<tr class="even">
<td>🍈</td>
<td>melon</td>
<td>U+1F348</td>
<td>f0 9f 8d 88</td>
<td>d83c df48</td>
<td>0001f348</td>
</tr>
<tr class="odd">
<td>🍉</td>
<td>watermelon</td>
<td>U+1F349</td>
<td>f0 9f 8d 89</td>
<td>d83c df49</td>
<td>0001f349</td>
</tr>
</tbody>
</table>
<p>In general, UTF-8 is the most suitable option for web pages and computer programs. The reason is only pragmatic because it makes the web engines and text editors and parsers work well when consuming most html, Javascript, and general purpose computer languages.</p>
<p>The Windows operating system uses APIs that handle the UTF-8 to UTF-16 conversion internally. In that way application code can pass UTF-8 encoded to the operating system.</p>
<section id="more-definitions" class="level3">
<h3 class="anchored" data-anchor-id="more-definitions">More definitions</h3>
<p>We are not done with definitions yet. Some additional considerations are necessary to process text correctly, for this a detailed reading of the Unicode standard is advised <span class="citation" data-cites="uni16:texthandling">[<a href="#ref-uni16:texthandling" role="doc-biblioref">5</a>]</span>. I will focus first on the difference between characters and glyphs.</p>
<p>A character is an abstract representation of a concrete mark made on paper or rendered to a computer screen, a so-called glyph. The character is the Unicode value that matches a glyph by convention.</p>
<p>The standard defines how to represent and how to identify a text character as a code point, however it does not provide rules for determining what a valid text element is because that depends on what the context is. Examples of context are capitalization for a title in English text, or the brake down of long sequences of characters at the end of text lines.</p>
<p>A text unit, thus is a valid sequence of one or more encoded text characters <span class="citation" data-cites="uni16:texthandling">[<a href="#ref-uni16:texthandling" role="doc-biblioref">5</a>]</span>.</p>
</section>
<section id="algorithms-for-text-encoding" class="level3">
<h3 class="anchored" data-anchor-id="algorithms-for-text-encoding">Algorithms for text encoding</h3>
<p>I will spare the reader with the specifics of these algorithms to go from code point to any of the encodings. A easy to follow example of these algorithms can be found elsewhere, I like the rich examples from this website: <a href="https://convertcodes.com/utf8-encode-decode-convert-string/">utf-8 encode-decode</a>. If you follow those examples you will realize a text processing program needs a table of code points to glyphs, and an algorithm to encode code points to code units and the reversal.</p>
</section>
</section>
<section id="why-does-all-of-this-matter" class="level2">
<h2 class="anchored" data-anchor-id="why-does-all-of-this-matter">Why does all of this matter?</h2>
<p>Text is used in the web and operating systems for any language, even for pseudo-languages like modern emojis. We have come to expect web apps, web sites, and our computers and mobile devices to be able to display our language and emojis correctly.</p>
<p>The programs that process text have to be break it down into its smallest components and then interpreted it as groups of characters that form words and punctuation, whole sentences, and whole paragraphs. And this has to work for any language supported by the software.</p>
<p>I am avoiding the discussion on general rules for displaying numbers, dates, and so on, commonly included in the definition of the locale used by a computer. Keeping the focus exclusively on text, the main technique to process it is called <strong>text boundary analysis</strong>. In a nutshell, this is about finding where lines can be wrapped for display, where sentences end, how to move a cursor for one word to the next, how to find words and count them, how to move the cursor one character at a time, etc. The ICU has an excellent explanation of it in its <a href="https://unicode-org.github.io/icu/userguide/boundaryanalysis/#overview-of-text-boundary-analysis">page on this subject</a>.</p>
</section>
<section id="simple-character-boundary-examples" class="level2">
<h2 class="anchored" data-anchor-id="simple-character-boundary-examples">Simple character boundary examples</h2>
<p>I will present examples of character boundary identification in different computer languages. We will limit the scope to identifying emoticons mixed in with text for rendering text using UTF-8 encoding as most modern editors and terminals would do.</p>
<p>I will be using emojis from the food-fruit category, as defined in the Unicode standard chart shown in the figure below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Food-fruit-unicode-emoji-chart.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 3. The table for the food-fruit emoji category taken from the Unicode standard chart <span class="citation" data-cites="uni16:emojicharts">[<a href="#ref-uni16:emojicharts" role="doc-biblioref">6</a>]</span></figcaption>
</figure>
</div>
<section id="c" class="level3">
<h3 class="anchored" data-anchor-id="c">C++</h3>
<p>The platform agnostic support for UTF-8 in C++ 20 is not quite as simple as in other modern computer languages. POSIX operating systems like Linux work with UTF-8 out of the box. However Windows uses UTF-16 internally, making every system call dependent on text encoding translations. Thankfully those translations are hidden under Windows API calls.</p>
<p>There is a C/C++ library for handling Unicode from the International Components for Unicode, ICU for short. This organization sits under the same umbrella of Unicode, Inc.&nbsp;The library is old judging by the 25 year-ago commits as of the time of writing. However, it is still maintained and it has been moved to GitHUb where it has a modern CI/CD pipeline. Furthermore the more modern Boost locale library uses the ICU libraries under the hood. These libraries are used by Linux packages everywhere to support internationalization.</p>
<p>In particular there is an ICU project that showcases the applications of the library through web pages for interactive text manipulation. The app for text segmentation is quite interesting. The app is hosted in <a href="https://icu4c-demos.unicode.org/icu-bin/icusegments#3/en">icusegments-demo</a>. The source code can be found in <a href="https://github.com/unicode-org/icu-demos">icu-demos</a> in GitHub.</p>
<p>I found that the pages are quite slow at certain times of day, using them is easier late at night in the North American time zones. Below is a successful test of the target sentence I want to parse by <em>grapheme cluster</em>, what we as users would identify as characters on the screen.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ICU_segments_sample.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure 2. The result from segmenting the test sentence using Unicode character boundaries using the web page at <a href="https://icu4c-demos.unicode.org/icu-bin/icusegments#0/en__ULI">icusegment</a>.</figcaption>
</figure>
</div>
<!-- The ICU libraries are everywhere in a Ubuntu operating system. -->
<!-- A quick search of one component shows it is packaged by many susbsystems: -->
<!-- Mon Feb 03, 01:15:15; pablo@XPS13:/usr/local/lib/cmake  -->
<!-- $ find / -type f -name libicuuc* 2>/dev/null -->
<!-- /snap/kf5-5-113-qt-5-15-11-core22/1/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/cups/1058/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/cups/1067/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/gnome-42-2204/176/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/gnome-42-2204/202/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/kf6-core22/40/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/kf6-core22/41/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/gnome-3-38-2004/140/usr/lib/x86_64-linux-gnu/libicuuc.so.66.1 -->
<!-- /snap/gnome-3-38-2004/143/usr/lib/x86_64-linux-gnu/libicuuc.so.66.1 -->
<!-- /snap/kf5-5-110-qt-5-15-11-core22/3/usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /snap/mesa-2404/44/usr/lib/i386-linux-gnu/libicuuc.so.74.2 -->
<!-- /snap/mesa-2404/44/usr/lib/x86_64-linux-gnu/libicuuc.so.74.2 -->
<!-- /snap/mesa-2404/143/usr/lib/i386-linux-gnu/libicuuc.so.74.2 -->
<!-- /snap/mesa-2404/143/usr/lib/x86_64-linux-gnu/libicuuc.so.74.2 -->
<!-- /usr/lib/x86_64-linux-gnu/libicuuc.so.70.1 -->
<!-- /usr/lib/x86_64-linux-gnu/libicuuc.a -->
<!-- /usr/lib/x86_64-linux-gnu/libicuuc.so.74.2 -->
<!-- /home/pablo/git/CPP/icu/icu4c/source/lib/libicuuc.so.77.0.1 -->
<!-- /home/pablo/.dropbox-dist/dropbox-lnx.x86_64-216.4.4420/libicuuc.so.42 -->
<!-- /opt/zoom/Qt/lib/libicuuc.so.56 -->
</section>
<section id="building-the-icu-library" class="level3">
<h3 class="anchored" data-anchor-id="building-the-icu-library">Building the ICU library</h3>
<p>The ICU library can be installed in a Ubuntu system either from the upstream repository through the package manager or by getting it from sources, then building and installing it locally. The last option is also available in a Windows operating system. Multiple versions can coexist simultaneously.</p>
<p>After cloning the project from <a href="https://github.com/unicode-org/icu/tree/main">ICU</a>, one can follow the steps in <a href="https://unicode-org.github.io/icu/userguide/icu4c/build.html">building-icu4c</a> to configure, build and install the version 77.0.1 as of the date of this writing. A minimal working example was then build using CMake. The only caveat is to explicitly link the ICU shared libraries necessary, as an example, using the GNU toolchain on Linux: <code>g++ your_file.cpp -o your_program -licuio -licui18n -licuuc</code>, for a program that needs the <code>libicuio.so</code>, <code>libicui18n.so</code>, and <code>libicuuc.so</code> shared libraries.</p>
</section>
<section id="the-c-test-driver-code" class="level3">
<h3 class="anchored" data-anchor-id="the-c-test-driver-code">The C++ test driver code</h3>
<p>As far as the code goes, below is a first attempt at illustrating what analysis we want to do. We want to segment an UTF-8 string with variable width code units that represent a blend of plain English ASCII and some emojis.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> fruit<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    fruit<span class="op">.</span>push_back<span class="op">(</span><span class="st">"🍇"</span><span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    fruit<span class="op">.</span>push_back<span class="op">(</span><span class="st">"🍈"</span><span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    fruit<span class="op">.</span>push_back<span class="op">(</span><span class="st">"🍉"</span><span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    fruit<span class="op">.</span>push_back<span class="op">(</span><span class="st">"🍊"</span><span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    fruit<span class="op">.</span>push_back<span class="op">(</span><span class="st">"🍋"</span><span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>test_string <span class="op">=</span> fruit<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>long_fruity_string <span class="op">=</span> <span class="st">"Hello "</span> <span class="op">+</span> test_string <span class="op">+</span> <span class="st">", "</span> <span class="op">+</span> fruit<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="st">"!"</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//Note: Since C++17 and ICU 76, you can use UTF-16 string literals with compile-time</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      length determination. </span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> icu<span class="op">::</span>UnicodeString str <span class="op">=</span> icu<span class="op">::</span>UnicodeString<span class="op">::</span>fromUTF8<span class="op">(</span>long_fruity_string<span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>st<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    str<span class="op">.</span>toUTF8String<span class="op">(</span>st<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"Sentence to parse: </span><span class="sc">\"</span><span class="st">"</span> <span class="op">&lt;&lt;</span> st <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\"</span><span class="st">"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    UErrorCode err <span class="op">=</span> U_ZERO_ERROR<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>icu<span class="op">::</span>BreakIterator<span class="op">&gt;</span> iter<span class="op">(</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        icu<span class="op">::</span>BreakIterator<span class="op">::</span>createCharacterInstance<span class="op">(</span>icu<span class="op">::</span>Locale<span class="op">::</span>getDefault<span class="op">(),</span> err<span class="op">));</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>U_SUCCESS<span class="op">(</span>err<span class="op">));</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    iter<span class="op">-&gt;</span>setText<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> start <span class="op">=</span> iter<span class="op">-&gt;</span>first<span class="op">();</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> end <span class="op">=</span> start<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>charToPrintUTF8<span class="op">{};</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ctp <span class="op">=</span> icu<span class="op">::</span>UnicodeString<span class="op">{};</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>iter<span class="op">-&gt;</span>next<span class="op">()</span> <span class="op">!=</span> icu<span class="op">::</span>BreakIterator<span class="op">::</span>DONE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> end<span class="op">;</span> <span class="co">// set start of the current grapheme before a pass throught the loop</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> iter<span class="op">-&gt;</span>current<span class="op">();</span> <span class="co">// update the end position of the current grapheme boundary found via iter-&gt;next </span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> len <span class="op">=</span> end <span class="op">-</span> start<span class="op">;</span> <span class="co">// in code units containing a grapheme</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        charToPrintUTF8<span class="op">.</span>clear<span class="op">();</span> </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        ctp <span class="op">=</span> str<span class="op">.</span>tempSubString<span class="op">(</span>start<span class="op">,</span> len<span class="op">);</span> </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        ctp<span class="op">.</span>toUTF8String<span class="op">(</span>charToPrintUTF8<span class="op">);</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> grapheme <span class="op">=</span> len<span class="op">&lt;</span><span class="dv">2</span><span class="op">?</span> <span class="bu">std::</span>string<span class="op">{</span>charToPrintUTF8<span class="op">.</span>front<span class="op">()}:</span> charToPrintUTF8<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">"Code units: "</span> <span class="op">&lt;&lt;</span> len <span class="op">&lt;&lt;</span> <span class="st">"; grapheme: '"</span> <span class="op">&lt;&lt;</span> grapheme <span class="op">&lt;&lt;</span> <span class="st">"' of "</span> <span class="op">&lt;&lt;</span> charToPrintUTF8<span class="op">.</span>length<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">" bytes"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The output is shown below when this code is compiled using the GNU compiler g++ 13.3 using the C++17 standard, the ICU libraries version 77.0.1 (built from latest GitHub as of this writing), <em>CMake</em> version 3.28.3 for the build system, and Ubuntu 24.04 for the Linux operating system. The output was edited to remove unnecessary details, linking to the ICU libraries is not a simple job, there is a learning curve to go through. The pay off for this complexity is a lot of control in the output.</p>
<pre><code>$ cmake ../ -DCMAKE_BUILD_TYPE=Debug
-- The C compiler identification is GNU 13.3.0
-- The CXX compiler identification is GNU 13.3.0
...
-- Found the following ICU libraries:
--   data (required): /usr/local/lib/libicudata.so
--   uc (required): /usr/local/lib/libicuuc.so
--   i18n (required): /usr/local/lib/libicui18n.so
--   io (required): /usr/local/lib/libicuio.so
-- Found ICU: /usr/local/include (found suitable version "77.0.1", minimum required is "77.0") 
-- Configuring done (0.4s)
-- Generating done (0.0s)
-- Build files have been written to: /home/pablo/git/CPP/character_boundaries/build-debug
Thu Jan 30, 21:48:26; pablo@XPS13:~/git/CPP/character_boundaries/build-debug 
$ make
[ 50%] Building CXX object CMakeFiles/cbd.dir/main.cpp.o
[100%] Linking CXX executable cbd
[100%] Built target cbd
Thu Jan 30, 22:58:20; pablo@XPS13:~/git/CPP/character_boundaries/build-debug [main]
$ ./cbd
Sentence to parse: "Hello 🍇, 🍈!"
Code units: 1; grapheme: 'H' of 1 bytes
Code units: 1; grapheme: 'e' of 1 bytes
Code units: 1; grapheme: 'l' of 1 bytes
Code units: 1; grapheme: 'l' of 1 bytes
Code units: 1; grapheme: 'o' of 1 bytes
Code units: 1; grapheme: ' ' of 1 bytes
Code units: 2; grapheme: '🍇' of 4 bytes
Code units: 1; grapheme: ',' of 1 bytes
Code units: 1; grapheme: ' ' of 1 bytes
Code units: 2; grapheme: '🍈' of 4 bytes
Code units: 1; grapheme: '!' of 1 bytes</code></pre>
<p>It is non-trivial to find the character boundaries in C++. The ICU <strong>BreakIterator</strong> for characters and its functions <strong>next()</strong> and <strong>current()</strong> apply rules for grapheme cluster identification based on the locale and the Unicode pages for the glyphs. When <strong>UnicodeString</strong> object is parsed into these <em>graphemes</em> and an individual one is converted to UTF-8 we observe that the regular letters of the English alphabet, the white space and the punctuation characters use 1 byte, as expected, while the fruit <em>emojis</em> take 4 bytes, also as expected.</p>
<p>The reader is invited to look under the hood to the complexity in the parsing algorithm to identify these <em>grapheme</em> clusters. This kind of software is infrastructure that has to remain hidden so we can communicate using all of our languages and all of the emojis of the world in our devices.</p>
<p>The reader is also invited to look up this <a href="https://stackoverflow.com/a/45581810/1585486">Stack Overflow answer</a> on doing exactly the same character segmentation exercise in C++ using the <strong>Boost</strong> library and its module called <strong>locale</strong>. It has a more modern interface in terms of function names and paradigm. However, as I mentioned earlier, it relies on the ICU libraries to do the detailed work. I like it that it uses the term <strong>boost::locale::boundary::character</strong> as the function to map over an UTF-8 string using an object of type <strong>boost::locale::boundary::csegment_index</strong>. It is all in the naming!</p>
<p>A caveat though, to be able to use <strong>Boost locale</strong> and the ICU libraries in the same executable their versions must match. The default Ubuntu 24.04 system Boost (v1.83) and ICU libraries (v74) did not match out out of the box because the Boost locale v1.83 was built with ICU v77. There is enough material for a full post on that subject alone.</p>
</section>
<section id="rust" class="level3">
<h3 class="anchored" data-anchor-id="rust">Rust</h3>
<p>In Rust I used the crate <code>emojis</code> from the official public registry. A <code>crate</code> is a module in Rust. For more details consult the free <a href="https://doc.rust-lang.org/cargo/index.html">cargo online book</a>.</p>
<p>The code creates a short vector with the first 5 elements of the Unicode emojis in the Food and Drink group. Then it creates a Rust String by concatenating String slices in UTF-8. It follows by using the magic of the String function <code>chars</code> to find the character boundaries and to print them one by one. The ‘magic’ comes from the fact that some of these characters have multiple code unit representations in UTF-8, the default this is the Unicode form used by the Rust String data type, regardless of the operating system.</p>
<p>In other words the function has to parse the byte sequence and using the UTF-8 decoding rules find whole characters, using the rules shown in Table 1. Once the base 16 Unicode code points are found a rendering function has to find them in a table and create the matching glyph on the terminal for printing.</p>
<p>Finally, the binary sequence for the whole sentence is printed to the terminal.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> emojis<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fruit<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="pp">emojis::Group::</span>FoodAndDrink<span class="op">.</span>emojis()<span class="op">.</span>map(<span class="op">|</span>e<span class="op">|</span> e<span class="op">.</span>as_str())<span class="op">.</span>take(<span class="dv">5</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(fruit<span class="op">,</span> [<span class="st">"🍇"</span><span class="op">,</span> <span class="st">"🍈"</span><span class="op">,</span> <span class="st">"🍉"</span><span class="op">,</span> <span class="st">"🍊"</span><span class="op">,</span> <span class="st">"🍋"</span>])<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> test_string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(fruit[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> long_fruity_string <span class="op">=</span> <span class="st">"Hello "</span><span class="op">.</span>to_owned() <span class="op">+</span> <span class="op">&amp;</span>test_string <span class="op">+</span> <span class="st">", "</span> <span class="op">+</span> fruit[<span class="dv">1</span>] <span class="op">+</span> <span class="st">"!"</span><span class="op">;</span> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"</span><span class="sc">\"</span><span class="st">{}</span><span class="sc">\"</span><span class="st">"</span><span class="op">,</span> long_fruity_string)<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> letter <span class="kw">in</span> long_fruity_string<span class="op">.</span>chars() <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">"{letter}"</span>)<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> long_fruity_string_in_binary <span class="op">=</span> <span class="st">""</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> character <span class="kw">in</span> long_fruity_string<span class="op">.</span>clone()<span class="op">.</span>into_bytes() <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        long_fruity_string_in_binary <span class="op">+=</span> <span class="op">&amp;</span><span class="pp">format!</span>(<span class="st">"0{:b} "</span><span class="op">,</span> character)<span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">r#""{}" in binary is "{}""#</span><span class="op">,</span> long_fruity_string<span class="op">,</span> long_fruity_string_in_binary)<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The output:</p>
<pre><code>$ cargo run
   Compiling character_boundary v0.1.0 (/home/pablo/git/Rust/rust-practice/character_boundary)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/character_boundary`
"Hello 🍇, 🍈!"
H
e
l
l
o
 
🍇
,
 
🍈
!
"Hello 🍇, 🍈!" in binary is "01001000 01100101 01101100 01101100 01101111 0100000 011110000 010011111 010001101 010000111 0101100 0100000 011110000 010011111 010001101 010001000 0100001 "</code></pre>
<p>Remember the rules for representing UTF-8 encoded bytes from standard Unicode points? Here are the first four of the last five bytes of the sentence: <code>11110000 10011111 10001101 10001000</code>, after removing the initial 0 that indicates binary numbers. Observe that these correspond to the 4 bytes of the multi-byte encoded character for the melon emoji: 🍈, with Unicode value U+1F348, and with value in UTF-8 encoding in hexadecimal as f0 9f 8d 88 (from Table 3).</p>
</section>
<section id="python" class="level3">
<h3 class="anchored" data-anchor-id="python">Python</h3>
<p>Pyhton 3 was a re-write of Python 2 in great part to make the language Unicode aware, therefore it is no surprise that it is one the most straight forward codes for our character boundary discovery exercise.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_each_grapheme( unicode_string: <span class="bu">str</span>):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    prints each unicode grapheme cluster</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    [<span class="bu">print</span>(c) <span class="cf">for</span> c <span class="kw">in</span> unicode_string]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span><span class="st">"__main__"</span>:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    runs the script when called as a stand alone</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    fruits <span class="op">=</span> <span class="st">u"🍇🍈🍉🍊🍋"</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    test_string <span class="op">=</span> fruits[<span class="dv">0</span>]</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    long_fruity_string <span class="op">=</span> <span class="st">"Hello "</span> <span class="op">+</span> test_string <span class="op">+</span> <span class="st">", "</span> <span class="op">+</span> fruits[<span class="dv">1</span>] <span class="op">+</span><span class="st">"!"</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    print_each_grapheme(long_fruity_string)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Python 3 extends the concept of a string to an array of Unicode grapheme clusters. This facilitates character boundary identification using the idiomatic list comprehension syntax and a string iterator. Under the hood the iterator is using Unicode code pages. The output is as expected.</p>
<pre><code>$ ./main.py 
H
e
l
l
o
 
🍇
,
 
🍈
!</code></pre>
</section>
<section id="r" class="level3">
<h3 class="anchored" data-anchor-id="r">R</h3>
<p>R has the <code>emoji</code> package. After a short exploration of its manual <span class="citation" data-cites="r-package:emoji">[<a href="#ref-r-package:emoji" role="doc-biblioref">7</a>]</span> it is possible to print the characters of a sentence using the fruit emojis by identifying their boundaries boundaries seamlessly.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">"emoji"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"emoji"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>fruit <span class="ot">&lt;-</span> emojis[ emojis<span class="sc">$</span>name <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"grapes"</span>, <span class="st">"watermelon"</span>, <span class="st">"melon"</span>, <span class="st">"lemon"</span>, <span class="st">"tangerine"</span>),]<span class="sc">$</span>emoji</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>test_string <span class="ot">&lt;-</span> fruit[<span class="dv">1</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>long_fruity_string <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">"Hello "</span>, test_string,<span class="st">", "</span>,fruit[<span class="dv">2</span>], <span class="st">"!"</span> )</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="fu">paste</span>(long_fruity_string)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(<span class="at">x =</span> long_fruity_string, <span class="at">split =</span> <span class="st">""</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#'strsplit' returns a list in case x has multiple strings to be processed, we grab only the first one</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>results[[<span class="dv">1</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Produces the following output, a vector of characters, due to R’s native focus on vectorized operations:</p>
<pre><code> [1] "Hello  🍇 ,  🍈 !"
 [1] "H"  "e"  "l"  "l"  "o"  " "  " "  "🍇" " "  ","  " "  " "  "🍈" " "  "!"</code></pre>
</section>
<section id="character-boundary-identification-complexity" class="level3">
<h3 class="anchored" data-anchor-id="character-boundary-identification-complexity">Character boundary identification complexity</h3>
<p>One might be tempted to think that character boundary is always a simple task. By simple I mean, decode the bytes into Unicode code points, look them up in tables, render each. However some languages have special symbols to compose the individual glyphs into sentences, these have to be identified and decomposed. To illustrate this look at the python and Rust examples below.</p>
<p>The text comes from this Stack Overflow question <a href="https://stackoverflow.com/q/4579215/1585486">cross-platform-iteration-of-unicode-string-counting-graphemes-using-icu</a></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> main <span class="im">import</span> print_each_grapheme</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    test_word <span class="op">=</span> <span class="st">"नमस्ते"</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    print_each_grapheme(test_word)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The output is correct because the two combining marks are discovered correctly.</p>
<p><img src="SO_graphemes_with_combining_marks_python.png" style="height:1.38889in"></p>
<p>Rust does likewise:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> emojis<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> tets_word <span class="op">=</span> <span class="st">"नमस्ते"</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"</span><span class="sc">\"</span><span class="st">{}</span><span class="sc">\"</span><span class="st">"</span><span class="op">,</span> tets_word)<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> letter <span class="kw">in</span> tets_word<span class="op">.</span>chars() <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">"{letter}"</span>)<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><img src="SO_grapheme_identification_rust.png" class="img-fluid"></p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Text representation using Unicode values and encondings has become an invisible technical detail. Its standardization, maintenance, and enhancement is in the hands of a few experts, interest groups and users that drive their constant adaptation to modern communication via the web.</p>
<p>Of the computer languages tested, Rust, Python, and R have a rich supply of modules for accessing Unicode glyphs by subject, and also for parsing and rendering functions that apply the Unicode standards. The ICU libraries in C++ have a more nuanced API. Boost C++ has put a more modern API to the ICU libraries but it takes developer effort to become productive quickly.</p>
<p>The needs of the world have evolved in the last decades towards more internationalization through the Internet, global supply chain, and international e-commerce and trade. Rust and Python 3 have been developed in the last 15 years and their developer experience reflects their conscious decision to treat Unicode as a first class citizen and become popular languages for modern application development. Java was not tested here.</p>
<p>All the software we use handles text encodings, most likely UTF-8 or UTF-16 like Windows does, via the libraries of the computer languages or the operating system. We saw examples of how well they do it for the simplest of operations. I hope this has given the reader a feel for the size of the task when it comes to writing software that processes text as data in diverse languages. From human readable representation to binary data that can travel through wires, optic fibre, or electromagnetic waves, text is everywhere and it is not going away any time soon.</p>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-uni16:emoji" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">Unicode Inc. <a href="https://unicode.org/reports/tr51/#Emoticons">Unicode technical standard #<span>51</span></a> 2024.</div>
</div>
<div id="ref-enwiki:1268238400_" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">Wikipedia contributors. <a href="https://en.wikipedia.org/w/index.php?title=UTF-8&amp;oldid=1268238400">UTF-8 — <span>Wikipedia</span><span>,</span> the free encyclopedia</a> 2025.</div>
</div>
<div id="ref-convertcodes:encodeformats" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">The anonymous engineering team. <a href="https://convertcodes.com/unicode-converter-encode-decode-utf/">Unicode converter – encode decode UTF text Base64</a> 2018.</div>
</div>
<div id="ref-uni16:encodingforms" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">Unicode Inc. <a href="https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G25539">Unicode 16<span>.</span>0<span>.</span>0 <span>Core Spec</span><span>,</span> unicode encoding forms</a> 2025.</div>
</div>
<div id="ref-uni16:texthandling" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">Unicode Inc. <a href="https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-1/#G9708">Unicode 16<span>.</span>0<span>.</span>0 <span>Core Spec</span><span>,</span> <span>1.3</span> text handling</a> 2025.</div>
</div>
<div id="ref-uni16:emojicharts" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">Unicode Inc. <a href="https://www.unicode.org/emoji/charts/emoji-list.html">Emoji charts, v<span>16.0</span></a> 2025.</div>
</div>
<div id="ref-r-package:emoji" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">Emil Hvitfeldt, Hadley Wickham. <a href="https://emilhvitfeldt.r-universe.dev/emoji/doc/manual.html">Package emoji, v<span>16.0.0.9000</span></a> 2025.</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>