---
title: "Rust will have generators"
author: "Pablo Adames"
date: "2025-08-23"
categories: [Rust, programming, iteration, generators]
bibliography: references.bib
csl: elsevier-vancouver.csl
format: html
knitr:
  opts_chunk: 
    collapse: true
    comment: "#>"
---

# Language evolution

Computer languages never stay  the same. They experience change in response to the needs of the industries they serve. These needs are discovered as adoption expands and meets the challenges of scale, efficiency, robustness, maintenance, tooling and safety.

Rust is a modern language that is characterized by two things: performance and memory safety. The other characteristic that is mentioned less frequently is that it is community driven, no benevolent dictators like in Python or ivory tower language committees like in C++. I believe that gives it the ability to experience gradual change delivered in an orderly fashion at constant pace, in other words you know what to expect and when to expect it. Dictators can be more often fast and chaotic, while committees can be in general slower and also too rigorous. 

The principle adopted by the language since the release of Rust 1.0 in May 2015 is called "stability without stagnation".  The governance model is a core team acting as stewards of the process to achieve consensus through open and public discussions in the format of Request for Comments (RFC) and Pull Requests (PR)  @theRustLanguageBlog:OSandOG. 


# How does Rust change? 

Rust changes at three levels, the compiler, the language, and the standard library. The release cadence is every six weeks. However the changes flow through the pipeline at different rates, depending on their nature. The language changes always start with an RFC triaged by the language sub-team. If approved, a team member is selected as Sheppard to help drive community involvement and ultimately consensus. 

There are more nuances to the process. For instance, to handle backwards-incompatible language changes they are wrapped into language Editions @theRustEditionLan:whatAreEditions. Each "crate", the Rust term for modules, can define the edition it works with out of the box. Also the developer can migrate a crate to a later edition via established back-compatibility rules. All of this allows software to not brake while change is actively managed according to the needs of the software maker.  


On October 10, 2023, RFC #3513 was tabled for a new language feature called `gen_blocks` @theRustRFCBook:gen_blocks or Generator blocks. Generators can be implemented in languages like Python, JavaScript, Ruby, Kotlin, Swift, C#, Haskell, and Rust. 
 

![Image credit: https://aigeeked.com/wp-content/uploads/2022/12/ai-text-generator.jpg/](https://aigeeked.com/wp-content/uploads/2022/12/ai-text-generator.jpg)

## What is a generator in computing languages?

In computer programming a generator is a way to express the iteration in a reactive way, in other words, if the iteration is done with an infinite loop, the values created in each iteration only exist when the iteration loop is carried out. This is also called lazy iteration and the function that does this is a lazy iterator. This allows one to write an infinite sequence that does not over flow the computer memory. 


## What problem do generators solve?

Fundamentally generators allow processing data structures that are too large to fit in the memory of the computer. Rust has iterators to express the concept of accessing the elements of a sequence of items @theRustBook:iterators. The implementation was done via the <span style="font-family: serif; color: red;"> Iterator</span> trait and the <span style="font-family: serif; color: red;"> next</span>  method.

```rust
fn main () -> Result<(), Box<dyn err>> {}
    let s = "Name,3678".to_string();
    let mut split = s.split(',');
    let (Some(name), Some(age), None) = (split.next(), split.next(), split.next()) else {
        return Err(ParsePersonError::BadLen);
    };
```



## The gen keyword in the 2024 Edition

As of the 2024 edition the term `gen` is reserved as a Rust language keyword. 

```rust

    // Test basic gen syntax
    let mut counter = gen {
        let mut n = 0;
        loop {
            yield n;
            n += 1;
        }
    };  

    println!("Basic counter generator:");
    for _ in 0..5 {
        if let CoroutineState::Yielded(value) = Pin::new(&mut counter).resume(()) {
            println!("Value: {}", value);
        }
    }   
```

```rust

    // Test Fibonacci generator
    let mut fibonacci = gen {
        let mut a = 0u64;
        let mut b = 1u64;
    
        yield a;
        yield b;
    
        loop {
            let next = a + b;
            yield next;
            a = b;
            b = next;
        }
    };  

    println!("Fibonacci generator:");
    for _ in 0..8 {
        if let CoroutineState::Yielded(value) = Pin::new(&mut fibonacci).resume(()) {
            print!("{} ", value);
        }
    }
```

## A practical example


## Summary and Conclusion


### References

::: {#refs}
:::
